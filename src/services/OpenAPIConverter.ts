import { SavedRequest } from './RequestHistory';
import {
    OpenAPIDocument,
    OpenAPIOperation,
    OpenAPIParameter,
    OpenAPIPathItem,
    APITesterCollection,
    OpenAPIResponseExample,
} from '../types/openapi';

export class OpenAPIConverter {
    /**
     * Convert saved requests to OpenAPI 3.0 document
     */
    static toOpenAPI(requests: SavedRequest[], title: string = 'API Collection'): APITesterCollection {
        const paths: Record<string, OpenAPIPathItem> = {};
        const servers: Set<string> = new Set();

        // Group requests by path and method
        requests.forEach((request) => {
            try {
                const url = new URL(request.url);
                const path = url.pathname;
                const server = `${url.protocol}//${url.host}`;
                servers.add(server);

                // Initialize path if not exists
                if (!paths[path]) {
                    paths[path] = {};
                }

                // Convert to OpenAPI operation
                const operation = this.requestToOperation(request, url);
                const method = request.method.toLowerCase();

                // Type-safe assignment
                switch (method) {
                    case 'get': paths[path].get = operation; break;
                    case 'post': paths[path].post = operation; break;
                    case 'put': paths[path].put = operation; break;
                    case 'patch': paths[path].patch = operation; break;
                    case 'delete': paths[path].delete = operation; break;
                    case 'head': paths[path].head = operation; break;
                    case 'options': paths[path].options = operation; break;
                    case 'trace': paths[path].trace = operation; break;
                }
            } catch (error) {
                console.error(`Failed to convert request: ${request.name}`, error);
            }
        });

        const document: OpenAPIDocument = {
            openapi: '3.0.3',
            info: {
                title,
                version: '1.0.0',
                description: 'Generated by API Tester Extension',
            },
            servers: Array.from(servers).map((url) => ({ url })),
            paths,
        };

        return {
            document,
            metadata: {
                createdAt: Date.now(),
                updatedAt: Date.now(),
                version: '1.0.0',
            },
        };
    }

    /**
     * Convert a saved request to OpenAPI operation
     */
    private static requestToOperation(request: SavedRequest, url: URL): OpenAPIOperation {
        const parameters: OpenAPIParameter[] = [];

        // Add query parameters
        url.searchParams.forEach((value, key) => {
            parameters.push({
                name: key,
                in: 'query',
                schema: { type: 'string' },
                example: value,
            });
        });

        // Add header parameters
        Object.entries(request.headers || {}).forEach(([key, value]) => {
            // Skip common headers that are usually set automatically
            if (!['content-type', 'user-agent', 'accept'].includes(key.toLowerCase())) {
                parameters.push({
                    name: key,
                    in: 'header',
                    schema: { type: 'string' },
                    example: value,
                });
            }
        });

        const operation: OpenAPIOperation = {
            summary: request.name,
            operationId: request.id,
            parameters: parameters.length > 0 ? parameters : undefined,
            responses: {
                '200': {
                    description: 'Success',
                },
            },
        };

        // Add request body if exists
        if (request.body) {
            const contentType = request.headers?.['Content-Type'] ||
                               request.headers?.['content-type'] ||
                               'application/json';

            operation.requestBody = {
                content: {
                    [contentType]: {
                        schema: { type: 'object' },
                        example: request.bodyType === 'json'
                            ? this.tryParseJSON(request.body)
                            : request.body,
                    },
                },
            };
        }

        // Add authentication
        if (request.auth && request.auth.type !== 'none') {
            operation.security = [this.authToSecurity(request.auth)];
        }

        // Store actual response data in extension field
        if (request.response) {
            operation['x-response'] = {
                status: request.response.status,
                statusText: request.response.statusText,
                headers: request.response.headers,
                body: request.response.body,
                time: request.response.time,
                size: request.response.size,
                timestamp: request.updatedAt,
            };

            // Add actual response to responses
            operation.responses[request.response.status.toString()] = {
                description: request.response.statusText,
                content: {
                    'application/json': {
                        example: this.tryParseJSON(request.response.body),
                    },
                },
            };
        }

        // Store collection info
        if (request.collectionId) {
            operation['x-collection'] = request.collectionId;
        }

        operation['x-timestamp'] = request.updatedAt;

        return operation;
    }

    /**
     * Convert OpenAPI document back to saved requests
     */
    static fromOpenAPI(collection: APITesterCollection): SavedRequest[] {
        const requests: SavedRequest[] = [];
        const { document } = collection;
        const defaultServer = document.servers?.[0]?.url || 'http://localhost:3000';

        Object.entries(document.paths).forEach(([path, pathItem]) => {
            const methods: (keyof OpenAPIPathItem)[] = ['get', 'post', 'put', 'patch', 'delete', 'head', 'options'];

            methods.forEach((method) => {
                const operation = pathItem[method] as OpenAPIOperation | undefined;
                if (operation) {
                    const request = this.operationToRequest(path, method, operation, defaultServer);
                    requests.push(request);
                }
            });
        });

        return requests;
    }

    /**
     * Convert OpenAPI operation to saved request
     */
    private static operationToRequest(
        path: string,
        method: string,
        operation: OpenAPIOperation,
        defaultServer: string
    ): SavedRequest {
        // Build URL with query parameters
        const url = new URL(path, defaultServer);
        const queryParams = operation.parameters?.filter((p) => p.in === 'query') || [];
        queryParams.forEach((param) => {
            if (param.example) {
                url.searchParams.append(param.name, String(param.example));
            }
        });

        // Build headers
        const headers: Record<string, string> = {};
        const headerParams = operation.parameters?.filter((p) => p.in === 'header') || [];
        headerParams.forEach((param) => {
            if (param.example) {
                headers[param.name] = String(param.example);
            }
        });

        // Get body
        let body = '';
        let bodyType: 'none' | 'json' | 'form' | 'text' | 'xml' = 'none';
        if (operation.requestBody) {
            const content = operation.requestBody.content;
            const contentType = Object.keys(content)[0];
            const mediaType = content[contentType];

            if (contentType.includes('json')) {
                bodyType = 'json';
                body = mediaType.example
                    ? JSON.stringify(mediaType.example, null, 2)
                    : '';
            } else if (contentType.includes('form')) {
                bodyType = 'form';
                body = mediaType.example || '';
            } else if (contentType.includes('xml')) {
                bodyType = 'xml';
                body = mediaType.example || '';
            } else {
                bodyType = 'text';
                body = mediaType.example || '';
            }

            headers['Content-Type'] = contentType;
        }

        // Get auth from security
        const auth = this.securityToAuth(operation.security?.[0]);

        // Get response from extension field
        const response = operation['x-response'];

        const timestamp = operation['x-timestamp'] || Date.now();

        return {
            id: operation.operationId || this.generateId(),
            name: operation.summary || `${method.toUpperCase()} ${path}`,
            method: method.toUpperCase(),
            url: url.toString(),
            headers,
            body,
            bodyType,
            auth,
            response,
            createdAt: timestamp,
            updatedAt: timestamp,
            collectionId: operation['x-collection'],
        };
    }

    /**
     * Convert auth to OpenAPI security requirement
     */
    private static authToSecurity(auth: any): Record<string, string[]> {
        switch (auth.type) {
            case 'bearer':
                return { bearerAuth: [] };
            case 'basic':
                return { basicAuth: [] };
            case 'apikey':
                return { apiKeyAuth: [] };
            default:
                return {};
        }
    }

    /**
     * Convert OpenAPI security to auth
     */
    private static securityToAuth(security?: Record<string, string[]>): any {
        if (!security) {
            return { type: 'none' };
        }

        const securityType = Object.keys(security)[0];
        if (securityType?.includes('bearer')) {
            return { type: 'bearer', token: '' };
        } else if (securityType?.includes('basic')) {
            return { type: 'basic', username: '', password: '' };
        } else if (securityType?.includes('apiKey')) {
            return { type: 'apikey', key: '', value: '' };
        }

        return { type: 'none' };
    }

    /**
     * Try to parse JSON, return original string if fails
     */
    private static tryParseJSON(str: string): any {
        try {
            return JSON.parse(str);
        } catch {
            return str;
        }
    }

    /**
     * Generate unique ID
     */
    private static generateId(): string {
        return `${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
    }

    /**
     * Export OpenAPI document as JSON string
     */
    static exportJSON(requests: SavedRequest[], title?: string): string {
        const collection = this.toOpenAPI(requests, title);
        return JSON.stringify(collection.document, null, 2);
    }

    /**
     * Import OpenAPI document from JSON string
     */
    static importJSON(json: string): SavedRequest[] {
        try {
            const document = JSON.parse(json) as OpenAPIDocument;
            const collection: APITesterCollection = {
                document,
                metadata: {
                    createdAt: Date.now(),
                    updatedAt: Date.now(),
                    version: '1.0.0',
                },
            };
            return this.fromOpenAPI(collection);
        } catch (error) {
            throw new Error(`Failed to import OpenAPI document: ${error}`);
        }
    }
}
