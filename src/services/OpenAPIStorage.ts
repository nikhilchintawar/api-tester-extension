import * as vscode from 'vscode';
import { OpenAPIDocument, OpenAPIOperation, OpenAPIPathItem, APITesterCollection } from '../types/openapi';
import { SavedRequest } from './RequestHistory';
import { OpenAPIConverter } from './OpenAPIConverter';

const STORAGE_KEY = 'apiTester.openapi';

/**
 * OpenAPI-first storage service
 * All data is stored in OpenAPI 3.0 format
 */
export class OpenAPIStorage {
    private context: vscode.ExtensionContext;
    private document: OpenAPIDocument;
    private metadata: APITesterCollection['metadata'];

    constructor(context: vscode.ExtensionContext) {
        this.context = context;

        // Initialize with empty document
        this.document = this.createEmptyDocument();
        this.metadata = {
            createdAt: Date.now(),
            updatedAt: Date.now(),
            version: '1.0.0',
        };

        // Load from storage
        this.load();
    }

    /**
     * Create an empty OpenAPI document
     */
    private createEmptyDocument(): OpenAPIDocument {
        return {
            openapi: '3.0.3',
            info: {
                title: 'API Test Collection',
                version: '1.0.0',
                description: 'Generated by API Tester Extension',
            },
            servers: [],
            paths: {},
        };
    }

    /**
     * Load OpenAPI document from storage
     */
    private async load(): Promise<void> {
        const stored = this.context.globalState.get<APITesterCollection>(STORAGE_KEY);

        if (stored && stored.document) {
            this.document = stored.document;
            this.metadata = stored.metadata;
            console.log('[OpenAPIStorage] Loaded document with', Object.keys(this.document.paths).length, 'paths');
        } else {
            // Try to migrate from old format
            await this.migrateFromLegacyFormat();
        }
    }

    /**
     * Save OpenAPI document to storage
     */
    private async save(): Promise<void> {
        this.metadata.updatedAt = Date.now();

        const collection: APITesterCollection = {
            document: this.document,
            metadata: this.metadata,
        };

        await this.context.globalState.update(STORAGE_KEY, collection);
        console.log('[OpenAPIStorage] Saved document with', Object.keys(this.document.paths).length, 'paths');
    }

    /**
     * Get all requests as flat array (for UI)
     */
    getRequests(): SavedRequest[] {
        return OpenAPIConverter.fromOpenAPI({
            document: this.document,
            metadata: this.metadata,
        });
    }

    /**
     * Add or update a request
     */
    async saveRequest(request: Omit<SavedRequest, 'id' | 'createdAt' | 'updatedAt'>): Promise<SavedRequest> {
        try {
            const url = new URL(request.url);
            const path = url.pathname;
            const method = request.method.toLowerCase();

            // Initialize path if doesn't exist
            if (!this.document.paths[path]) {
                this.document.paths[path] = {};
            }

            // Check if operation already exists
            const pathItem = this.document.paths[path];
            const existingOp = pathItem[method as keyof OpenAPIPathItem] as OpenAPIOperation | undefined;

            // Generate or reuse operation ID
            const operationId = existingOp?.operationId || this.generateId();
            const createdAt = existingOp?.['x-timestamp'] || Date.now();
            const updatedAt = Date.now();

            // Convert request to operation
            const operation = this.requestToOperation(request, url, operationId, createdAt, updatedAt);

            // Add server if not exists
            const serverUrl = `${url.protocol}//${url.host}`;
            if (!this.document.servers?.some(s => s.url === serverUrl)) {
                if (!this.document.servers) {
                    this.document.servers = [];
                }
                this.document.servers.push({ url: serverUrl });
            }

            // Set operation
            switch (method) {
                case 'get': pathItem.get = operation; break;
                case 'post': pathItem.post = operation; break;
                case 'put': pathItem.put = operation; break;
                case 'patch': pathItem.patch = operation; break;
                case 'delete': pathItem.delete = operation; break;
                case 'head': pathItem.head = operation; break;
                case 'options': pathItem.options = operation; break;
                case 'trace': pathItem.trace = operation; break;
            }

            await this.save();

            // Return as SavedRequest
            return {
                id: operationId,
                name: operation.summary || `${request.method} ${path}`,
                method: request.method,
                url: request.url,
                headers: request.headers || {},
                body: request.body,
                bodyType: request.bodyType,
                auth: request.auth,
                response: request.response,
                createdAt,
                updatedAt,
            };
        } catch (error) {
            console.error('[OpenAPIStorage] Failed to save request:', error);
            throw error;
        }
    }

    /**
     * Delete a request
     */
    async deleteRequest(url: string, method: string): Promise<boolean> {
        try {
            const urlObj = new URL(url);
            const path = urlObj.pathname;
            const methodLower = method.toLowerCase();

            if (!this.document.paths[path]) {
                return false;
            }

            const pathItem = this.document.paths[path];
            delete pathItem[methodLower as keyof OpenAPIPathItem];

            // Remove path if empty
            if (Object.keys(pathItem).length === 0) {
                delete this.document.paths[path];
            }

            await this.save();
            return true;
        } catch (error) {
            console.error('[OpenAPIStorage] Failed to delete request:', error);
            return false;
        }
    }

    /**
     * Get the full OpenAPI document
     */
    getDocument(): OpenAPIDocument {
        return this.document;
    }

    /**
     * Set the entire OpenAPI document (for import)
     */
    async setDocument(document: OpenAPIDocument): Promise<void> {
        this.document = document;
        await this.save();
    }

    /**
     * Export as JSON string
     */
    exportJSON(): string {
        return JSON.stringify(this.document, null, 2);
    }

    /**
     * Import from JSON string
     */
    async importJSON(json: string): Promise<{ imported: number; errors: string[] }> {
        const errors: string[] = [];
        let imported = 0;

        try {
            const importedDoc = JSON.parse(json) as OpenAPIDocument;

            // Merge paths
            Object.entries(importedDoc.paths).forEach(([path, pathItem]) => {
                if (!this.document.paths[path]) {
                    this.document.paths[path] = {};
                }

                // Merge operations
                const methods: (keyof OpenAPIPathItem)[] = ['get', 'post', 'put', 'patch', 'delete', 'head', 'options', 'trace'];
                methods.forEach((method) => {
                    const operation = pathItem[method];
                    if (operation) {
                        this.document.paths[path][method] = operation as any;
                        imported++;
                    }
                });
            });

            // Merge servers
            if (importedDoc.servers) {
                const existingServers = new Set(this.document.servers?.map(s => s.url) || []);
                importedDoc.servers.forEach((server) => {
                    if (!existingServers.has(server.url)) {
                        if (!this.document.servers) {
                            this.document.servers = [];
                        }
                        this.document.servers.push(server);
                    }
                });
            }

            await this.save();
        } catch (error) {
            errors.push(`Failed to import: ${error}`);
        }

        return { imported, errors };
    }

    /**
     * Clear all data
     */
    async clear(): Promise<void> {
        this.document = this.createEmptyDocument();
        await this.save();
    }

    /**
     * Convert SavedRequest to OpenAPI operation
     */
    private requestToOperation(
        request: Omit<SavedRequest, 'id' | 'createdAt' | 'updatedAt'>,
        url: URL,
        operationId: string,
        createdAt: number,
        updatedAt: number
    ): OpenAPIOperation {
        const parameters: any[] = [];

        // Query parameters
        url.searchParams.forEach((value, key) => {
            parameters.push({
                name: key,
                in: 'query',
                schema: { type: 'string' },
                example: value,
            });
        });

        // Header parameters
        Object.entries(request.headers || {}).forEach(([key, value]) => {
            if (!['content-type', 'user-agent', 'accept'].includes(key.toLowerCase())) {
                parameters.push({
                    name: key,
                    in: 'header',
                    schema: { type: 'string' },
                    example: value,
                });
            }
        });

        const operation: OpenAPIOperation = {
            summary: request.name || `${request.method} ${url.pathname}`,
            operationId,
            parameters: parameters.length > 0 ? parameters : undefined,
            responses: {
                '200': { description: 'Success' },
            },
            'x-timestamp': updatedAt,
        };

        // Request body
        if (request.body) {
            const contentType = request.headers?.['Content-Type'] ||
                               request.headers?.['content-type'] ||
                               'application/json';

            operation.requestBody = {
                content: {
                    [contentType]: {
                        schema: { type: 'object' },
                        example: request.bodyType === 'json'
                            ? this.tryParseJSON(request.body)
                            : request.body,
                    },
                },
            };
        }

        // Response
        if (request.response) {
            operation['x-response'] = {
                status: request.response.status,
                statusText: request.response.statusText,
                headers: request.response.headers,
                body: request.response.body,
                time: request.response.time,
                size: request.response.size,
                timestamp: updatedAt,
            };

            operation.responses[request.response.status.toString()] = {
                description: request.response.statusText,
                content: {
                    'application/json': {
                        example: this.tryParseJSON(request.response.body),
                    },
                },
            };
        }

        return operation;
    }

    /**
     * Migrate from legacy SavedRequest[] format
     */
    private async migrateFromLegacyFormat(): Promise<void> {
        const legacyRequests = this.context.globalState.get<SavedRequest[]>('apiTester.savedRequests', []);

        if (legacyRequests.length > 0) {
            console.log('[OpenAPIStorage] Migrating', legacyRequests.length, 'requests from legacy format');

            const collection = OpenAPIConverter.toOpenAPI(legacyRequests, 'Migrated API Collection');
            this.document = collection.document;
            this.metadata = collection.metadata;

            await this.save();

            console.log('[OpenAPIStorage] Migration complete!');
        }
    }

    private tryParseJSON(str: string): any {
        try {
            return JSON.parse(str);
        } catch {
            return str;
        }
    }

    private generateId(): string {
        return `${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
    }
}
